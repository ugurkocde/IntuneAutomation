{
  "variables": {
    "runbookType": "PowerShell",
    "logProgress": false,
    "scriptContent": "<#\\n.TITLE\\n    Apple Token Validity Checker\\n\\n.SYNOPSIS\\n    Monitor and report on the validity and expiration status of Apple DEP tokens and Push Notification Certificates in Intune.\\n\\n.DESCRIPTION\\n    This script connects to Microsoft Graph and retrieves all Apple Device Enrollment Program (DEP) tokens \\n    and Apple Push Notification Certificates configured in Intune. It checks their validity status, \\n    expiration dates, and sync status to help administrators proactively manage Apple Business Manager \\n    integrations. The script generates detailed reports in CSV format, highlighting tokens and certificates \\n    that are expired, expiring soon, or have sync issues.\\n\\n.TAGS\\n    Monitoring\\n\\n.MINROLE\\n    Intune Administrator\\n\\n.PERMISSIONS\\n    DeviceManagementServiceConfig.Read.All,DeviceManagementConfiguration.Read.All\\n\\n.AUTHOR\\n    Ugur Koc\\n\\n.VERSION\\n    1.0\\n\\n.CHANGELOG\\n    1.0 - Initial release\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1\\n    Generates Apple token validity reports for all DEP tokens and Push Notification Certificates\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1 -OutputPath \\\"C:\\\\Reports\\\" -ExpirationWarningDays 60\\n    Generates reports with 60-day expiration warning and saves to specified directory\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1 -OnlyShowProblems -SendEmailAlert\\n    Shows only problematic tokens and certificates and sends email alerts for critical issues\\n\\n.NOTES\\n    - Requires Microsoft.Graph.Authentication module: Install-Module Microsoft.Graph.Authentication\\n    - Requires appropriate permissions in Azure AD\\n    - DEP tokens are valid for one year from creation\\n    - Apple Push Notification Certificates are valid for one year from creation\\n    - Automatic sync occurs daily, manual sync can be triggered\\n    - Critical for maintaining iOS/macOS device and app management\\n#>\\n\\n[CmdletBinding()]\\nparam(\\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Directory path to save reports\\\")]\\n    [ValidateNotNullOrEmpty()]\\n    [string]$OutputPath = \\\".\\\",\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Number of days before expiration to show warnings\\\")]\\n    [ValidateRange(1, 365)]\\n    [int]$ExpirationWarningDays = 30,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Only show tokens with problems\\\")]\\n    [switch]$OnlyShowProblems,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Send email alert for critical issues\\\")]\\n    [switch]$SendEmailAlert,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Email address to send alerts to\\\")]\\n    [string]$AlertEmailAddress = \\\"\\\"\\n)\\n\\n# ============================================================================\\n# AUTHENTICATION - DUAL ENVIRONMENT SUPPORT\\n# ============================================================================\\n\\n# Detect execution environment\\nif ($PSPrivateMetadata.JobId.Guid) {\\n    Write-Output \\\"Running inside Azure Automation Runbook\\\"\\n    $IsRunbook = $true\\n} else {\\n    Write-Output \\\"Running locally in IDE or terminal\\\"\\n    $IsRunbook = $false\\n}\\n\\n# Authentication logic based on environment\\nif ($IsRunbook) {\\n    # Azure Automation Runbook - Use Managed Identity\\n    try {\\n        Write-Output \\\"Connecting to Microsoft Graph using Managed Identity...\\\"\\n        Connect-MgGraph -Identity -NoWelcome\\n        Write-Output \\\"‚úì Successfully connected to Microsoft Graph using Managed Identity\\\"\\n    }\\n    catch {\\n        Write-Error \\\"Failed to connect to Microsoft Graph using Managed Identity: $(<#\\n.TITLE\\n    Apple Token Validity Checker\\n\\n.SYNOPSIS\\n    Monitor and report on the validity and expiration status of Apple DEP tokens and Push Notification Certificates in Intune.\\n\\n.DESCRIPTION\\n    This script connects to Microsoft Graph and retrieves all Apple Device Enrollment Program (DEP) tokens \\n    and Apple Push Notification Certificates configured in Intune. It checks their validity status, \\n    expiration dates, and sync status to help administrators proactively manage Apple Business Manager \\n    integrations. The script generates detailed reports in CSV format, highlighting tokens and certificates \\n    that are expired, expiring soon, or have sync issues.\\n\\n.TAGS\\n    Monitoring\\n\\n.MINROLE\\n    Intune Administrator\\n\\n.PERMISSIONS\\n    DeviceManagementServiceConfig.Read.All,DeviceManagementConfiguration.Read.All\\n\\n.AUTHOR\\n    Ugur Koc\\n\\n.VERSION\\n    1.0\\n\\n.CHANGELOG\\n    1.0 - Initial release\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1\\n    Generates Apple token validity reports for all DEP tokens and Push Notification Certificates\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1 -OutputPath \\\"C:\\\\Reports\\\" -ExpirationWarningDays 60\\n    Generates reports with 60-day expiration warning and saves to specified directory\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1 -OnlyShowProblems -SendEmailAlert\\n    Shows only problematic tokens and certificates and sends email alerts for critical issues\\n\\n.NOTES\\n    - Requires Microsoft.Graph.Authentication module: Install-Module Microsoft.Graph.Authentication\\n    - Requires appropriate permissions in Azure AD\\n    - DEP tokens are valid for one year from creation\\n    - Apple Push Notification Certificates are valid for one year from creation\\n    - Automatic sync occurs daily, manual sync can be triggered\\n    - Critical for maintaining iOS/macOS device and app management\\n#>\\n\\n[CmdletBinding()]\\nparam(\\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Directory path to save reports\\\")]\\n    [ValidateNotNullOrEmpty()]\\n    [string]$OutputPath = \\\".\\\",\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Number of days before expiration to show warnings\\\")]\\n    [ValidateRange(1, 365)]\\n    [int]$ExpirationWarningDays = 30,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Only show tokens with problems\\\")]\\n    [switch]$OnlyShowProblems,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Send email alert for critical issues\\\")]\\n    [switch]$SendEmailAlert,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Email address to send alerts to\\\")]\\n    [string]$AlertEmailAddress = \\\"\\\"\\n)\\n\\n# ============================================================================\\n# MODULES AND AUTHENTICATION\\n# ============================================================================\\n\\n# Check if required modules are installed\\n$RequiredModuleList = @(\\n    \\\"Microsoft.Graph.Authentication\\\"\\n)\\n\\nforeach ($Module in $RequiredModuleList) {\\n    if (-not (Get-Module -ListAvailable -Name $Module)) {\\n        Write-Error \\\"$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser\\\"\\n        exit 1\\n    }\\n}\\n\\n# Import required modules\\nforeach ($Module in $RequiredModuleList) {\\n    Import-Module $Module\\n}\\n\\n# Connect to Microsoft Graph\\ntry {\\n    Write-Information \\\"Connecting to Microsoft Graph...\\\" -InformationAction Continue\\n    $Scopes = @(\\n        \\\"DeviceManagementServiceConfig.Read.All\\\",\\n        \\\"DeviceManagementConfiguration.Read.All\\\"\\n    )\\n    Connect-MgGraph -Scopes $Scopes -NoWelcome | Out-Null\\n    Write-Information \\\"‚úì Successfully connected to Microsoft Graph\\\" -InformationAction Continue\\n}\\ncatch {\\n    Write-Error \\\"Failed to connect to Microsoft Graph: $($_.Exception.Message)\\\"\\n    exit 1\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS\\n# ============================================================================\\n\\n# Function to get all pages of results from Graph API\\nfunction Get-MgGraphPaginatedData {\\n    param(\\n        [Parameter(Mandatory = $true)]\\n        [string]$Uri,\\n        [int]$DelayMs = 100\\n    )\\n    \\n    $AllResult = @()\\n    $NextLink = $Uri\\n    $RequestCount = 0\\n    \\n    do {\\n        try {\\n            # Add delay to respect rate limits\\n            if ($RequestCount -gt 0) {\\n                Start-Sleep -Milliseconds $DelayMs\\n            }\\n            \\n            $Response = Invoke-MgGraphRequest -Uri $NextLink -Method GET\\n            $RequestCount++\\n            \\n            if ($Response.value) {\\n                $AllResult += $Response.value\\n            }\\n            else {\\n                $AllResult += $Response\\n            }\\n            \\n            $NextLink = $Response.'@odata.nextLink'\\n        }\\n        catch {\\n            if ($_.Exception.Message -like \\\"*429*\\\" -or $_.Exception.Message -like \\\"*throttled*\\\") {\\n                Write-Information \\\"`nRate limit hit, waiting 60 seconds...\\\" -InformationAction Continue\\n                Start-Sleep -Seconds 60\\n                continue\\n            }\\n            Write-Warning \\\"Error fetching data from $NextLink : $($_.Exception.Message)\\\"\\n            break\\n        }\\n    } while ($NextLink)\\n    \\n    return $AllResult\\n}\\n\\n# Function to determine token health status\\nfunction Get-TokenHealthStatus {\\n    param(\\n        [string]$State,\\n        [datetime]$ExpirationDate,\\n        [string]$LastSyncStatus,\\n        [int]$WarningDays\\n    )\\n    \\n    $DaysUntilExpiration = ($ExpirationDate - (Get-Date)).Days\\n    \\n    # Determine overall health\\n    if ($State -eq \\\"expired\\\" -or $DaysUntilExpiration -le 0) {\\n        return \\\"Critical\\\"\\n    }\\n    elseif ($State -eq \\\"invalid\\\" -or $LastSyncStatus -eq \\\"failed\\\") {\\n        return \\\"Critical\\\"\\n    }\\n    elseif ($DaysUntilExpiration -le $WarningDays) {\\n        return \\\"Warning\\\"\\n    }\\n    elseif ($State -eq \\\"valid\\\" -and $LastSyncStatus -eq \\\"completed\\\") {\\n        return \\\"Healthy\\\"\\n    }\\n    else {\\n        return \\\"Unknown\\\"\\n    }\\n}\\n\\n# Function to format time span\\nfunction Format-TimeSpan {\\n    param([datetime]$Date)\\n    \\n    $TimeSpan = $Date - (Get-Date)\\n    \\n    if ($TimeSpan.TotalDays -gt 0) {\\n        return \\\"$([math]::Round($TimeSpan.TotalDays)) days\\\"\\n    }\\n    elseif ($TimeSpan.TotalDays -gt -1) {\\n        return \\\"Today\\\"\\n    }\\n    else {\\n        return \\\"$([math]::Abs([math]::Round($TimeSpan.TotalDays))) days ago\\\"\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN SCRIPT LOGIC\\n# ============================================================================\\n\\ntry {\\n    Write-Information \\\"Starting Apple token validity check...\\\" -InformationAction Continue\\n    \\n    # Initialize results arrays\\n    $AllTokens = @()\\n    $CriticalIssues = @()\\n    \\n    # ========================================================================\\n    # GET DEP TOKENS (ENROLLMENT PROGRAM TOKENS)\\n    # ========================================================================\\n    \\n    Write-Information \\\"Retrieving Apple DEP tokens...\\\" -InformationAction Continue\\n    \\n    try {\\n        $DepTokensUri = \\\"https://graph.microsoft.com/beta/deviceManagement/depOnboardingSettings\\\"\\n        $DepTokens = Get-MgGraphPaginatedData -Uri $DepTokensUri\\n        Write-Information \\\"Retrieving $($DepTokens.Count) DEP token entries...\\\" -InformationAction Continue\\n        \\n        $ValidDepTokenCount = 0\\n        foreach ($Token in $DepTokens) {\\n            try {\\n                # Skip if essential fields are missing\\n                if (-not $Token.tokenExpirationDateTime -or -not $Token.id) {\\n                    Write-Verbose \\\"Skipping DEP token entry with missing essential fields (ID: $($Token.id))\\\"\\n                    continue\\n                }\\n                \\n                $ExpirationDate = [datetime]$Token.tokenExpirationDateTime\\n                $LastSyncDate = if ($Token.lastSuccessfulSyncDateTime) { [datetime]$Token.lastSuccessfulSyncDateTime } else { $null }\\n                \\n                # DEP tokens don't have the same state enum as VPP, so we determine state based on expiration\\n                $State = if ($ExpirationDate -lt (Get-Date)) { \\\"expired\\\" } else { \\\"valid\\\" }\\n                $LastSyncStatus = if ($Token.lastSyncErrorCode -eq 0 -or $null -eq $Token.lastSyncErrorCode) { \\\"completed\\\" } else { \\\"failed\\\" }\\n                \\n                $HealthStatus = Get-TokenHealthStatus -State $State -ExpirationDate $ExpirationDate -LastSyncStatus $LastSyncStatus -WarningDays $ExpirationWarningDays\\n                \\n                $TokenInfo = [PSCustomObject]@{\\n                    TokenType            = \\\"DEP\\\"\\n                    TokenName            = if ($Token.tokenName) { $Token.tokenName } else { \\\"Unknown DEP Token\\\" }\\n                    AppleId              = if ($Token.appleIdentifier) { $Token.appleIdentifier } else { \\\"Unknown\\\" }\\n                    State                = $State\\n                    AccountType          = if ($Token.tokenType) { $Token.tokenType } else { \\\"Unknown\\\" }\\n                    CountryRegion        = \\\"N/A\\\"\\n                    ExpirationDateTime   = $ExpirationDate\\n                    DaysUntilExpiration  = ($ExpirationDate - (Get-Date)).Days\\n                    ExpirationStatus     = Format-TimeSpan -Date $ExpirationDate\\n                    LastSyncDateTime     = $LastSyncDate\\n                    LastSyncStatus       = $LastSyncStatus\\n                    AutoUpdateApps       = \\\"N/A\\\"\\n                    HealthStatus         = $HealthStatus\\n                    TokenId              = $Token.id\\n                    LastModifiedDateTime = if ($Token.lastModifiedDateTime) { [datetime]$Token.lastModifiedDateTime } else { $null }\\n                }\\n                \\n                $AllTokens += $TokenInfo\\n                $ValidDepTokenCount++\\n                \\n                # Track critical issues\\n                if ($HealthStatus -eq \\\"Critical\\\") {\\n                    $CriticalIssues += $TokenInfo\\n                }\\n            }\\n            catch {\\n                Write-Verbose \\\"Error processing DEP token (ID: $($Token.id)): $($_.Exception.Message)\\\"\\n                continue\\n            }\\n        }\\n        \\n        Write-Information \\\"‚úì Found $ValidDepTokenCount valid DEP tokens\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Warning \\\"Failed to retrieve DEP tokens: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # GET APPLE PUSH NOTIFICATION CERTIFICATE\\n    # ========================================================================\\n    \\n    Write-Information \\\"Retrieving Apple Push Notification Certificate...\\\" -InformationAction Continue\\n    \\n    try {\\n        $ApnsCertUri = \\\"https://graph.microsoft.com/v1.0/deviceManagement/applePushNotificationCertificate\\\"\\n        $ApnsCert = Invoke-MgGraphRequest -Uri $ApnsCertUri -Method GET\\n        \\n        if ($ApnsCert) {\\n            Write-Information \\\"‚úì Found Apple Push Notification Certificate\\\" -InformationAction Continue\\n            \\n            $ExpirationDate = [datetime]$ApnsCert.expirationDateTime\\n            $LastModifiedDate = if ($ApnsCert.lastModifiedDateTime) { [datetime]$ApnsCert.lastModifiedDateTime } else { $null }\\n            \\n            # Determine certificate state based on expiration and upload status\\n            $State = if ($ExpirationDate -lt (Get-Date)) { \\n                \\\"expired\\\" \\n            }\\n            elseif ([string]::IsNullOrEmpty($ApnsCert.certificateUploadFailureReason)) { \\n                \\\"valid\\\" \\n            }\\n            else { \\n                \\\"invalid\\\" \\n            }\\n            \\n            # Determine sync status based on certificate upload status and failure reason\\n            $LastSyncStatus = if ([string]::IsNullOrEmpty($ApnsCert.certificateUploadFailureReason)) { \\\"completed\\\" } else { \\\"failed\\\" }\\n            \\n            # Debug output to help understand the actual certificate status\\n            Write-Verbose \\\"APNS Certificate Debug Info:\\\"\\n            Write-Verbose \\\"  Upload Status: '$($ApnsCert.certificateUploadStatus)'\\\"\\n            Write-Verbose \\\"  Failure Reason: '$($ApnsCert.certificateUploadFailureReason)'\\\"\\n            Write-Verbose \\\"  Has Certificate: $([bool]$ApnsCert.certificate)\\\"\\n            Write-Verbose \\\"  Determined State: '$State'\\\"\\n            \\n            $HealthStatus = Get-TokenHealthStatus -State $State -ExpirationDate $ExpirationDate -LastSyncStatus $LastSyncStatus -WarningDays $ExpirationWarningDays\\n            \\n            $TokenInfo = [PSCustomObject]@{\\n                TokenType                      = \\\"APNS\\\"\\n                TokenName                      = \\\"Apple Push Notification Certificate\\\"\\n                AppleId                        = $ApnsCert.appleIdentifier\\n                State                          = $State\\n                AccountType                    = \\\"Push Certificate\\\"\\n                CountryRegion                  = \\\"N/A\\\"\\n                ExpirationDateTime             = $ExpirationDate\\n                DaysUntilExpiration            = ($ExpirationDate - (Get-Date)).Days\\n                ExpirationStatus               = Format-TimeSpan -Date $ExpirationDate\\n                LastSyncDateTime               = $LastModifiedDate\\n                LastSyncStatus                 = $LastSyncStatus\\n                AutoUpdateApps                 = \\\"N/A\\\"\\n                HealthStatus                   = $HealthStatus\\n                TokenId                        = $ApnsCert.id\\n                LastModifiedDateTime           = $LastModifiedDate\\n                TopicIdentifier                = $ApnsCert.topicIdentifier\\n                CertificateUploadStatus        = $ApnsCert.certificateUploadStatus\\n                CertificateUploadFailureReason = $ApnsCert.certificateUploadFailureReason\\n                CertificateSerialNumber        = $ApnsCert.certificateSerialNumber\\n            }\\n            \\n            $AllTokens += $TokenInfo\\n            \\n            # Track critical issues\\n            if ($HealthStatus -eq \\\"Critical\\\") {\\n                $CriticalIssues += $TokenInfo\\n            }\\n        }\\n        else {\\n            Write-Information \\\"‚ÑπÔ∏è No Apple Push Notification Certificate found\\\" -InformationAction Continue\\n        }\\n    }\\n    catch {\\n        Write-Warning \\\"Failed to retrieve Apple Push Notification Certificate: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # FILTER RESULTS IF REQUESTED\\n    # ========================================================================\\n    \\n    $ReportTokens = if ($OnlyShowProblems) {\\n        $AllTokens | Where-Object { $_.HealthStatus -in @(\\\"Critical\\\", \\\"Warning\\\") }\\n    }\\n    else {\\n        $AllTokens\\n    }\\n    \\n    # ========================================================================\\n    # GENERATE CSV REPORT\\n    # ========================================================================\\n    \\n    # Generate timestamp for file names\\n    $Timestamp = Get-Date -Format \\\"yyyy-MM-dd_HH-mm-ss\\\"\\n    $CsvPath = Join-Path $OutputPath \\\"Apple_Token_Validity_Report_$Timestamp.csv\\\"\\n    \\n    # Export to CSV\\n    try {\\n        $ReportTokens | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8\\n        Write-Information \\\"‚úì CSV report saved: $CsvPath\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Error \\\"Failed to generate CSV report: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # SEND EMAIL ALERTS IF REQUESTED\\n    # ========================================================================\\n    \\n    if ($SendEmailAlert -and $CriticalIssues.Count -gt 0 -and $AlertEmailAddress) {\\n        Write-Information \\\"Sending email alert for critical issues...\\\" -InformationAction Continue\\n        # Note: Email functionality would require additional modules and configuration\\n        # This is a placeholder for future implementation\\n        Write-Warning \\\"Email alert functionality requires additional configuration (SMTP settings, etc.)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # DISPLAY DETAILED CONSOLE OUTPUT\\n    # ========================================================================\\n    \\n    Write-Information \\\"`nüçé APPLE TOKEN & CERTIFICATE VALIDITY SUMMARY\\\" -InformationAction Continue\\n    Write-Information \\\"==============================================\\\" -InformationAction Continue\\n    Write-Information \\\"Total Items: $($AllTokens.Count)\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ DEP Tokens: $(($AllTokens | Where-Object { $_.TokenType -eq 'DEP' }).Count)\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ APNS Certificates: $(($AllTokens | Where-Object { $_.TokenType -eq 'APNS' }).Count)\\\" -InformationAction Continue\\n    Write-Information \\\"\\\" -InformationAction Continue\\n    \\n    # Health Status Summary\\n    $HealthyCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Healthy\\\" }).Count\\n    $WarningCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Warning\\\" }).Count\\n    $CriticalCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Critical\\\" }).Count\\n    $UnknownCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Unknown\\\" }).Count\\n    \\n    Write-Information \\\"Health Status:\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Healthy: $HealthyCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Warning: $WarningCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Critical: $CriticalCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Unknown: $UnknownCount\\\" -InformationAction Continue\\n    \\n    # Display detailed token information\\n    if ($ReportTokens.Count -gt 0) {\\n        Write-Information \\\"`nüìã TOKEN DETAILS:\\\" -InformationAction Continue\\n        Write-Information \\\"=================\\\" -InformationAction Continue\\n        \\n        foreach ($Token in ($ReportTokens | Sort-Object HealthStatus, DaysUntilExpiration)) {\\n            $StatusIcon = switch ($Token.HealthStatus) {\\n                \\\"Healthy\\\" { \\\"‚úÖ\\\" }\\n                \\\"Warning\\\" { \\\"‚ö†Ô∏è\\\" }\\n                \\\"Critical\\\" { \\\"‚ùå\\\" }\\n                default { \\\"‚ùì\\\" }\\n            }\\n            \\n            $ItemType = if ($Token.TokenType -eq \\\"APNS\\\") { \\\"Certificate\\\" } else { \\\"Token\\\" }\\n            Write-Information \\\"`n$StatusIcon $($Token.TokenType) $ItemType : $($Token.TokenName)\\\" -InformationAction Continue\\n            Write-Information \\\"   Apple ID: $($Token.AppleId)\\\" -InformationAction Continue\\n            Write-Information \\\"   Status: $($Token.State)\\\" -InformationAction Continue\\n            Write-Information \\\"   Health: $($Token.HealthStatus)\\\" -InformationAction Continue\\n            Write-Information \\\"   Expires: $($Token.ExpirationDateTime.ToString('yyyy-MM-dd')) ($($Token.ExpirationStatus))\\\" -InformationAction Continue\\n            Write-Information \\\"   Last Modified: $(if ($Token.LastSyncDateTime) { $Token.LastSyncDateTime.ToString('yyyy-MM-dd HH:mm') } else { 'Never' })\\\" -InformationAction Continue\\n            Write-Information \\\"   Status: $($Token.LastSyncStatus)\\\" -InformationAction Continue\\n            \\n            if ($Token.TokenType -eq \\\"APNS\\\") {\\n                Write-Information \\\"   Topic Identifier: $($Token.TopicIdentifier)\\\" -InformationAction Continue\\n                Write-Information \\\"   Upload Status: $($Token.CertificateUploadStatus)\\\" -InformationAction Continue\\n                Write-Information \\\"   Serial Number: $($Token.CertificateSerialNumber)\\\" -InformationAction Continue\\n                if ($Token.CertificateUploadFailureReason) {\\n                    Write-Information \\\"   Upload Failure Reason: $($Token.CertificateUploadFailureReason)\\\" -InformationAction Continue\\n                }\\n            }\\n        }\\n    }\\n    \\n    # Critical Issues Alert\\n    if ($CriticalIssues.Count -gt 0) {\\n        Write-Information \\\"`n‚ö†Ô∏è  CRITICAL ISSUES DETECTED:\\\" -InformationAction Continue\\n        Write-Information \\\"=============================\\\" -InformationAction Continue\\n        foreach ($Issue in $CriticalIssues) {\\n            Write-Information \\\"‚ùå $($Issue.TokenName) ($($Issue.TokenType))\\\" -InformationAction Continue\\n            Write-Information \\\"   Issue: $($Issue.State)\\\" -InformationAction Continue\\n            Write-Information \\\"   Expires: $($Issue.ExpirationStatus)\\\" -InformationAction Continue\\n            Write-Information \\\"   Action Required: $(if ($Issue.State -eq 'expired') { 'Replace token immediately' } elseif ($Issue.State -eq 'invalid') { 'Check Apple Business Manager configuration' } else { 'Investigate sync issues' })\\\" -InformationAction Continue\\n            Write-Information \\\"\\\" -InformationAction Continue\\n        }\\n    }\\n    \\n    # Recommendations\\n    Write-Information \\\"`nüìã RECOMMENDATIONS:\\\" -InformationAction Continue\\n    Write-Information \\\"===================\\\" -InformationAction Continue\\n    \\n    $ExpiringTokens = $AllTokens | Where-Object { $_.DaysUntilExpiration -le $ExpirationWarningDays -and $_.DaysUntilExpiration -gt 0 }\\n    if ($ExpiringTokens.Count -gt 0) {\\n        Write-Information \\\"üîÑ Renew $($ExpiringTokens.Count) token(s) expiring within $ExpirationWarningDays days:\\\" -InformationAction Continue\\n        foreach ($Token in $ExpiringTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType)) - expires in $($Token.DaysUntilExpiration) days\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    $FailedSyncTokens = $AllTokens | Where-Object { $_.LastSyncStatus -eq \\\"failed\\\" }\\n    if ($FailedSyncTokens.Count -gt 0) {\\n        Write-Information \\\"üîç Investigate $($FailedSyncTokens.Count) token(s) with failed sync status:\\\" -InformationAction Continue\\n        foreach ($Token in $FailedSyncTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType))\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    $ExpiredTokens = $AllTokens | Where-Object { $_.DaysUntilExpiration -le 0 }\\n    if ($ExpiredTokens.Count -gt 0) {\\n        Write-Information \\\"üö® Replace $($ExpiredTokens.Count) expired token(s) immediately:\\\" -InformationAction Continue\\n        foreach ($Token in $ExpiredTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType)) - expired $([math]::Abs($Token.DaysUntilExpiration)) days ago\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    if ($HealthyCount -eq $AllTokens.Count) {\\n        Write-Information \\\"‚úÖ All tokens are healthy! No action required.\\\" -InformationAction Continue\\n    }\\n    \\n    Write-Information \\\"`nReport saved to:\\\" -InformationAction Continue\\n    Write-Information \\\"üìÑ CSV: $CsvPath\\\" -InformationAction Continue\\n    \\n    Write-Information \\\"`n‚úì Apple token validity check completed successfully\\\" -InformationAction Continue\\n}\\ncatch {\\n    Write-Error \\\"Script failed: $($_.Exception.Message)\\\"\\n    exit 1\\n}\\nfinally {\\n    # Cleanup operations\\n    try {\\n        Disconnect-MgGraph -ErrorAction SilentlyContinue | Out-Null\\n        Write-Information \\\"Disconnected from Microsoft Graph\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Verbose \\\"Disconnect operation completed with warnings (this is expected behavior)\\\"\\n    }\\n}\\n\\n# ============================================================================\\n# SCRIPT SUMMARY\\n# ============================================================================\\n\\nWrite-Information \\\"\\n========================================\\nScript Execution Summary\\n========================================\\nScript: Apple Token & Certificate Validity Checker\\nTotal Items Checked: $($AllTokens.Count)\\n  ‚Ä¢ DEP Tokens: $(($AllTokens | Where-Object { $_.TokenType -eq 'DEP' }).Count)\\n  ‚Ä¢ APNS Certificates: $(($AllTokens | Where-Object { $_.TokenType -eq 'APNS' }).Count)\\nCritical Issues: $($CriticalIssues.Count)\\nStatus: Completed\\n========================================\\n\\\" -InformationAction Continue.Exception.Message)\\\"\\n        throw\\n    }\\n} else {\\n    # Local execution - Use interactive authentication\\n    # Check if required modules are installed\\n    $RequiredModules = @(\\n        \\\"Microsoft.Graph.Authentication\\\"\\n    )\\n\\n    foreach ($Module in $RequiredModules) {\\n        if (-not (Get-Module -ListAvailable -Name $Module)) {\\n            Write-Error \\\"$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser\\\"\\n            exit 1\\n        }\\n    }\\n\\n    # Import required modules\\n    foreach ($Module in $RequiredModules) {\\n        Import-Module $Module\\n    }\\n\\n    # Connect to Microsoft Graph with required scopes\\n    try {\\n        Write-Information \\\"Connecting to Microsoft Graph...\\\" -InformationAction Continue\\n        $Scopes = @(\\n            \\\"DeviceManagementServiceConfig.Read.All,DeviceManagementConfiguration.Read.All\\\"\\n        )\\n        Connect-MgGraph -Scopes $Scopes -NoWelcome\\n        Write-Information \\\"‚úì Successfully connected to Microsoft Graph\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Error \\\"Failed to connect to Microsoft Graph: $(<#\\n.TITLE\\n    Apple Token Validity Checker\\n\\n.SYNOPSIS\\n    Monitor and report on the validity and expiration status of Apple DEP tokens and Push Notification Certificates in Intune.\\n\\n.DESCRIPTION\\n    This script connects to Microsoft Graph and retrieves all Apple Device Enrollment Program (DEP) tokens \\n    and Apple Push Notification Certificates configured in Intune. It checks their validity status, \\n    expiration dates, and sync status to help administrators proactively manage Apple Business Manager \\n    integrations. The script generates detailed reports in CSV format, highlighting tokens and certificates \\n    that are expired, expiring soon, or have sync issues.\\n\\n.TAGS\\n    Monitoring\\n\\n.MINROLE\\n    Intune Administrator\\n\\n.PERMISSIONS\\n    DeviceManagementServiceConfig.Read.All,DeviceManagementConfiguration.Read.All\\n\\n.AUTHOR\\n    Ugur Koc\\n\\n.VERSION\\n    1.0\\n\\n.CHANGELOG\\n    1.0 - Initial release\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1\\n    Generates Apple token validity reports for all DEP tokens and Push Notification Certificates\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1 -OutputPath \\\"C:\\\\Reports\\\" -ExpirationWarningDays 60\\n    Generates reports with 60-day expiration warning and saves to specified directory\\n\\n.EXAMPLE\\n    .\\\\check-apple-token-validity.ps1 -OnlyShowProblems -SendEmailAlert\\n    Shows only problematic tokens and certificates and sends email alerts for critical issues\\n\\n.NOTES\\n    - Requires Microsoft.Graph.Authentication module: Install-Module Microsoft.Graph.Authentication\\n    - Requires appropriate permissions in Azure AD\\n    - DEP tokens are valid for one year from creation\\n    - Apple Push Notification Certificates are valid for one year from creation\\n    - Automatic sync occurs daily, manual sync can be triggered\\n    - Critical for maintaining iOS/macOS device and app management\\n#>\\n\\n[CmdletBinding()]\\nparam(\\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Directory path to save reports\\\")]\\n    [ValidateNotNullOrEmpty()]\\n    [string]$OutputPath = \\\".\\\",\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Number of days before expiration to show warnings\\\")]\\n    [ValidateRange(1, 365)]\\n    [int]$ExpirationWarningDays = 30,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Only show tokens with problems\\\")]\\n    [switch]$OnlyShowProblems,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Send email alert for critical issues\\\")]\\n    [switch]$SendEmailAlert,\\n    \\n    [Parameter(Mandatory = $false, HelpMessage = \\\"Email address to send alerts to\\\")]\\n    [string]$AlertEmailAddress = \\\"\\\"\\n)\\n\\n# ============================================================================\\n# MODULES AND AUTHENTICATION\\n# ============================================================================\\n\\n# Check if required modules are installed\\n$RequiredModuleList = @(\\n    \\\"Microsoft.Graph.Authentication\\\"\\n)\\n\\nforeach ($Module in $RequiredModuleList) {\\n    if (-not (Get-Module -ListAvailable -Name $Module)) {\\n        Write-Error \\\"$Module module is required. Install it using: Install-Module $Module -Scope CurrentUser\\\"\\n        exit 1\\n    }\\n}\\n\\n# Import required modules\\nforeach ($Module in $RequiredModuleList) {\\n    Import-Module $Module\\n}\\n\\n# Connect to Microsoft Graph\\ntry {\\n    Write-Information \\\"Connecting to Microsoft Graph...\\\" -InformationAction Continue\\n    $Scopes = @(\\n        \\\"DeviceManagementServiceConfig.Read.All\\\",\\n        \\\"DeviceManagementConfiguration.Read.All\\\"\\n    )\\n    Connect-MgGraph -Scopes $Scopes -NoWelcome | Out-Null\\n    Write-Information \\\"‚úì Successfully connected to Microsoft Graph\\\" -InformationAction Continue\\n}\\ncatch {\\n    Write-Error \\\"Failed to connect to Microsoft Graph: $($_.Exception.Message)\\\"\\n    exit 1\\n}\\n\\n# ============================================================================\\n# HELPER FUNCTIONS\\n# ============================================================================\\n\\n# Function to get all pages of results from Graph API\\nfunction Get-MgGraphPaginatedData {\\n    param(\\n        [Parameter(Mandatory = $true)]\\n        [string]$Uri,\\n        [int]$DelayMs = 100\\n    )\\n    \\n    $AllResult = @()\\n    $NextLink = $Uri\\n    $RequestCount = 0\\n    \\n    do {\\n        try {\\n            # Add delay to respect rate limits\\n            if ($RequestCount -gt 0) {\\n                Start-Sleep -Milliseconds $DelayMs\\n            }\\n            \\n            $Response = Invoke-MgGraphRequest -Uri $NextLink -Method GET\\n            $RequestCount++\\n            \\n            if ($Response.value) {\\n                $AllResult += $Response.value\\n            }\\n            else {\\n                $AllResult += $Response\\n            }\\n            \\n            $NextLink = $Response.'@odata.nextLink'\\n        }\\n        catch {\\n            if ($_.Exception.Message -like \\\"*429*\\\" -or $_.Exception.Message -like \\\"*throttled*\\\") {\\n                Write-Information \\\"`nRate limit hit, waiting 60 seconds...\\\" -InformationAction Continue\\n                Start-Sleep -Seconds 60\\n                continue\\n            }\\n            Write-Warning \\\"Error fetching data from $NextLink : $($_.Exception.Message)\\\"\\n            break\\n        }\\n    } while ($NextLink)\\n    \\n    return $AllResult\\n}\\n\\n# Function to determine token health status\\nfunction Get-TokenHealthStatus {\\n    param(\\n        [string]$State,\\n        [datetime]$ExpirationDate,\\n        [string]$LastSyncStatus,\\n        [int]$WarningDays\\n    )\\n    \\n    $DaysUntilExpiration = ($ExpirationDate - (Get-Date)).Days\\n    \\n    # Determine overall health\\n    if ($State -eq \\\"expired\\\" -or $DaysUntilExpiration -le 0) {\\n        return \\\"Critical\\\"\\n    }\\n    elseif ($State -eq \\\"invalid\\\" -or $LastSyncStatus -eq \\\"failed\\\") {\\n        return \\\"Critical\\\"\\n    }\\n    elseif ($DaysUntilExpiration -le $WarningDays) {\\n        return \\\"Warning\\\"\\n    }\\n    elseif ($State -eq \\\"valid\\\" -and $LastSyncStatus -eq \\\"completed\\\") {\\n        return \\\"Healthy\\\"\\n    }\\n    else {\\n        return \\\"Unknown\\\"\\n    }\\n}\\n\\n# Function to format time span\\nfunction Format-TimeSpan {\\n    param([datetime]$Date)\\n    \\n    $TimeSpan = $Date - (Get-Date)\\n    \\n    if ($TimeSpan.TotalDays -gt 0) {\\n        return \\\"$([math]::Round($TimeSpan.TotalDays)) days\\\"\\n    }\\n    elseif ($TimeSpan.TotalDays -gt -1) {\\n        return \\\"Today\\\"\\n    }\\n    else {\\n        return \\\"$([math]::Abs([math]::Round($TimeSpan.TotalDays))) days ago\\\"\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN SCRIPT LOGIC\\n# ============================================================================\\n\\ntry {\\n    Write-Information \\\"Starting Apple token validity check...\\\" -InformationAction Continue\\n    \\n    # Initialize results arrays\\n    $AllTokens = @()\\n    $CriticalIssues = @()\\n    \\n    # ========================================================================\\n    # GET DEP TOKENS (ENROLLMENT PROGRAM TOKENS)\\n    # ========================================================================\\n    \\n    Write-Information \\\"Retrieving Apple DEP tokens...\\\" -InformationAction Continue\\n    \\n    try {\\n        $DepTokensUri = \\\"https://graph.microsoft.com/beta/deviceManagement/depOnboardingSettings\\\"\\n        $DepTokens = Get-MgGraphPaginatedData -Uri $DepTokensUri\\n        Write-Information \\\"Retrieving $($DepTokens.Count) DEP token entries...\\\" -InformationAction Continue\\n        \\n        $ValidDepTokenCount = 0\\n        foreach ($Token in $DepTokens) {\\n            try {\\n                # Skip if essential fields are missing\\n                if (-not $Token.tokenExpirationDateTime -or -not $Token.id) {\\n                    Write-Verbose \\\"Skipping DEP token entry with missing essential fields (ID: $($Token.id))\\\"\\n                    continue\\n                }\\n                \\n                $ExpirationDate = [datetime]$Token.tokenExpirationDateTime\\n                $LastSyncDate = if ($Token.lastSuccessfulSyncDateTime) { [datetime]$Token.lastSuccessfulSyncDateTime } else { $null }\\n                \\n                # DEP tokens don't have the same state enum as VPP, so we determine state based on expiration\\n                $State = if ($ExpirationDate -lt (Get-Date)) { \\\"expired\\\" } else { \\\"valid\\\" }\\n                $LastSyncStatus = if ($Token.lastSyncErrorCode -eq 0 -or $null -eq $Token.lastSyncErrorCode) { \\\"completed\\\" } else { \\\"failed\\\" }\\n                \\n                $HealthStatus = Get-TokenHealthStatus -State $State -ExpirationDate $ExpirationDate -LastSyncStatus $LastSyncStatus -WarningDays $ExpirationWarningDays\\n                \\n                $TokenInfo = [PSCustomObject]@{\\n                    TokenType            = \\\"DEP\\\"\\n                    TokenName            = if ($Token.tokenName) { $Token.tokenName } else { \\\"Unknown DEP Token\\\" }\\n                    AppleId              = if ($Token.appleIdentifier) { $Token.appleIdentifier } else { \\\"Unknown\\\" }\\n                    State                = $State\\n                    AccountType          = if ($Token.tokenType) { $Token.tokenType } else { \\\"Unknown\\\" }\\n                    CountryRegion        = \\\"N/A\\\"\\n                    ExpirationDateTime   = $ExpirationDate\\n                    DaysUntilExpiration  = ($ExpirationDate - (Get-Date)).Days\\n                    ExpirationStatus     = Format-TimeSpan -Date $ExpirationDate\\n                    LastSyncDateTime     = $LastSyncDate\\n                    LastSyncStatus       = $LastSyncStatus\\n                    AutoUpdateApps       = \\\"N/A\\\"\\n                    HealthStatus         = $HealthStatus\\n                    TokenId              = $Token.id\\n                    LastModifiedDateTime = if ($Token.lastModifiedDateTime) { [datetime]$Token.lastModifiedDateTime } else { $null }\\n                }\\n                \\n                $AllTokens += $TokenInfo\\n                $ValidDepTokenCount++\\n                \\n                # Track critical issues\\n                if ($HealthStatus -eq \\\"Critical\\\") {\\n                    $CriticalIssues += $TokenInfo\\n                }\\n            }\\n            catch {\\n                Write-Verbose \\\"Error processing DEP token (ID: $($Token.id)): $($_.Exception.Message)\\\"\\n                continue\\n            }\\n        }\\n        \\n        Write-Information \\\"‚úì Found $ValidDepTokenCount valid DEP tokens\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Warning \\\"Failed to retrieve DEP tokens: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # GET APPLE PUSH NOTIFICATION CERTIFICATE\\n    # ========================================================================\\n    \\n    Write-Information \\\"Retrieving Apple Push Notification Certificate...\\\" -InformationAction Continue\\n    \\n    try {\\n        $ApnsCertUri = \\\"https://graph.microsoft.com/v1.0/deviceManagement/applePushNotificationCertificate\\\"\\n        $ApnsCert = Invoke-MgGraphRequest -Uri $ApnsCertUri -Method GET\\n        \\n        if ($ApnsCert) {\\n            Write-Information \\\"‚úì Found Apple Push Notification Certificate\\\" -InformationAction Continue\\n            \\n            $ExpirationDate = [datetime]$ApnsCert.expirationDateTime\\n            $LastModifiedDate = if ($ApnsCert.lastModifiedDateTime) { [datetime]$ApnsCert.lastModifiedDateTime } else { $null }\\n            \\n            # Determine certificate state based on expiration and upload status\\n            $State = if ($ExpirationDate -lt (Get-Date)) { \\n                \\\"expired\\\" \\n            }\\n            elseif ([string]::IsNullOrEmpty($ApnsCert.certificateUploadFailureReason)) { \\n                \\\"valid\\\" \\n            }\\n            else { \\n                \\\"invalid\\\" \\n            }\\n            \\n            # Determine sync status based on certificate upload status and failure reason\\n            $LastSyncStatus = if ([string]::IsNullOrEmpty($ApnsCert.certificateUploadFailureReason)) { \\\"completed\\\" } else { \\\"failed\\\" }\\n            \\n            # Debug output to help understand the actual certificate status\\n            Write-Verbose \\\"APNS Certificate Debug Info:\\\"\\n            Write-Verbose \\\"  Upload Status: '$($ApnsCert.certificateUploadStatus)'\\\"\\n            Write-Verbose \\\"  Failure Reason: '$($ApnsCert.certificateUploadFailureReason)'\\\"\\n            Write-Verbose \\\"  Has Certificate: $([bool]$ApnsCert.certificate)\\\"\\n            Write-Verbose \\\"  Determined State: '$State'\\\"\\n            \\n            $HealthStatus = Get-TokenHealthStatus -State $State -ExpirationDate $ExpirationDate -LastSyncStatus $LastSyncStatus -WarningDays $ExpirationWarningDays\\n            \\n            $TokenInfo = [PSCustomObject]@{\\n                TokenType                      = \\\"APNS\\\"\\n                TokenName                      = \\\"Apple Push Notification Certificate\\\"\\n                AppleId                        = $ApnsCert.appleIdentifier\\n                State                          = $State\\n                AccountType                    = \\\"Push Certificate\\\"\\n                CountryRegion                  = \\\"N/A\\\"\\n                ExpirationDateTime             = $ExpirationDate\\n                DaysUntilExpiration            = ($ExpirationDate - (Get-Date)).Days\\n                ExpirationStatus               = Format-TimeSpan -Date $ExpirationDate\\n                LastSyncDateTime               = $LastModifiedDate\\n                LastSyncStatus                 = $LastSyncStatus\\n                AutoUpdateApps                 = \\\"N/A\\\"\\n                HealthStatus                   = $HealthStatus\\n                TokenId                        = $ApnsCert.id\\n                LastModifiedDateTime           = $LastModifiedDate\\n                TopicIdentifier                = $ApnsCert.topicIdentifier\\n                CertificateUploadStatus        = $ApnsCert.certificateUploadStatus\\n                CertificateUploadFailureReason = $ApnsCert.certificateUploadFailureReason\\n                CertificateSerialNumber        = $ApnsCert.certificateSerialNumber\\n            }\\n            \\n            $AllTokens += $TokenInfo\\n            \\n            # Track critical issues\\n            if ($HealthStatus -eq \\\"Critical\\\") {\\n                $CriticalIssues += $TokenInfo\\n            }\\n        }\\n        else {\\n            Write-Information \\\"‚ÑπÔ∏è No Apple Push Notification Certificate found\\\" -InformationAction Continue\\n        }\\n    }\\n    catch {\\n        Write-Warning \\\"Failed to retrieve Apple Push Notification Certificate: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # FILTER RESULTS IF REQUESTED\\n    # ========================================================================\\n    \\n    $ReportTokens = if ($OnlyShowProblems) {\\n        $AllTokens | Where-Object { $_.HealthStatus -in @(\\\"Critical\\\", \\\"Warning\\\") }\\n    }\\n    else {\\n        $AllTokens\\n    }\\n    \\n    # ========================================================================\\n    # GENERATE CSV REPORT\\n    # ========================================================================\\n    \\n    # Generate timestamp for file names\\n    $Timestamp = Get-Date -Format \\\"yyyy-MM-dd_HH-mm-ss\\\"\\n    $CsvPath = Join-Path $OutputPath \\\"Apple_Token_Validity_Report_$Timestamp.csv\\\"\\n    \\n    # Export to CSV\\n    try {\\n        $ReportTokens | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8\\n        Write-Information \\\"‚úì CSV report saved: $CsvPath\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Error \\\"Failed to generate CSV report: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # SEND EMAIL ALERTS IF REQUESTED\\n    # ========================================================================\\n    \\n    if ($SendEmailAlert -and $CriticalIssues.Count -gt 0 -and $AlertEmailAddress) {\\n        Write-Information \\\"Sending email alert for critical issues...\\\" -InformationAction Continue\\n        # Note: Email functionality would require additional modules and configuration\\n        # This is a placeholder for future implementation\\n        Write-Warning \\\"Email alert functionality requires additional configuration (SMTP settings, etc.)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # DISPLAY DETAILED CONSOLE OUTPUT\\n    # ========================================================================\\n    \\n    Write-Information \\\"`nüçé APPLE TOKEN & CERTIFICATE VALIDITY SUMMARY\\\" -InformationAction Continue\\n    Write-Information \\\"==============================================\\\" -InformationAction Continue\\n    Write-Information \\\"Total Items: $($AllTokens.Count)\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ DEP Tokens: $(($AllTokens | Where-Object { $_.TokenType -eq 'DEP' }).Count)\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ APNS Certificates: $(($AllTokens | Where-Object { $_.TokenType -eq 'APNS' }).Count)\\\" -InformationAction Continue\\n    Write-Information \\\"\\\" -InformationAction Continue\\n    \\n    # Health Status Summary\\n    $HealthyCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Healthy\\\" }).Count\\n    $WarningCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Warning\\\" }).Count\\n    $CriticalCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Critical\\\" }).Count\\n    $UnknownCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Unknown\\\" }).Count\\n    \\n    Write-Information \\\"Health Status:\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Healthy: $HealthyCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Warning: $WarningCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Critical: $CriticalCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Unknown: $UnknownCount\\\" -InformationAction Continue\\n    \\n    # Display detailed token information\\n    if ($ReportTokens.Count -gt 0) {\\n        Write-Information \\\"`nüìã TOKEN DETAILS:\\\" -InformationAction Continue\\n        Write-Information \\\"=================\\\" -InformationAction Continue\\n        \\n        foreach ($Token in ($ReportTokens | Sort-Object HealthStatus, DaysUntilExpiration)) {\\n            $StatusIcon = switch ($Token.HealthStatus) {\\n                \\\"Healthy\\\" { \\\"‚úÖ\\\" }\\n                \\\"Warning\\\" { \\\"‚ö†Ô∏è\\\" }\\n                \\\"Critical\\\" { \\\"‚ùå\\\" }\\n                default { \\\"‚ùì\\\" }\\n            }\\n            \\n            $ItemType = if ($Token.TokenType -eq \\\"APNS\\\") { \\\"Certificate\\\" } else { \\\"Token\\\" }\\n            Write-Information \\\"`n$StatusIcon $($Token.TokenType) $ItemType : $($Token.TokenName)\\\" -InformationAction Continue\\n            Write-Information \\\"   Apple ID: $($Token.AppleId)\\\" -InformationAction Continue\\n            Write-Information \\\"   Status: $($Token.State)\\\" -InformationAction Continue\\n            Write-Information \\\"   Health: $($Token.HealthStatus)\\\" -InformationAction Continue\\n            Write-Information \\\"   Expires: $($Token.ExpirationDateTime.ToString('yyyy-MM-dd')) ($($Token.ExpirationStatus))\\\" -InformationAction Continue\\n            Write-Information \\\"   Last Modified: $(if ($Token.LastSyncDateTime) { $Token.LastSyncDateTime.ToString('yyyy-MM-dd HH:mm') } else { 'Never' })\\\" -InformationAction Continue\\n            Write-Information \\\"   Status: $($Token.LastSyncStatus)\\\" -InformationAction Continue\\n            \\n            if ($Token.TokenType -eq \\\"APNS\\\") {\\n                Write-Information \\\"   Topic Identifier: $($Token.TopicIdentifier)\\\" -InformationAction Continue\\n                Write-Information \\\"   Upload Status: $($Token.CertificateUploadStatus)\\\" -InformationAction Continue\\n                Write-Information \\\"   Serial Number: $($Token.CertificateSerialNumber)\\\" -InformationAction Continue\\n                if ($Token.CertificateUploadFailureReason) {\\n                    Write-Information \\\"   Upload Failure Reason: $($Token.CertificateUploadFailureReason)\\\" -InformationAction Continue\\n                }\\n            }\\n        }\\n    }\\n    \\n    # Critical Issues Alert\\n    if ($CriticalIssues.Count -gt 0) {\\n        Write-Information \\\"`n‚ö†Ô∏è  CRITICAL ISSUES DETECTED:\\\" -InformationAction Continue\\n        Write-Information \\\"=============================\\\" -InformationAction Continue\\n        foreach ($Issue in $CriticalIssues) {\\n            Write-Information \\\"‚ùå $($Issue.TokenName) ($($Issue.TokenType))\\\" -InformationAction Continue\\n            Write-Information \\\"   Issue: $($Issue.State)\\\" -InformationAction Continue\\n            Write-Information \\\"   Expires: $($Issue.ExpirationStatus)\\\" -InformationAction Continue\\n            Write-Information \\\"   Action Required: $(if ($Issue.State -eq 'expired') { 'Replace token immediately' } elseif ($Issue.State -eq 'invalid') { 'Check Apple Business Manager configuration' } else { 'Investigate sync issues' })\\\" -InformationAction Continue\\n            Write-Information \\\"\\\" -InformationAction Continue\\n        }\\n    }\\n    \\n    # Recommendations\\n    Write-Information \\\"`nüìã RECOMMENDATIONS:\\\" -InformationAction Continue\\n    Write-Information \\\"===================\\\" -InformationAction Continue\\n    \\n    $ExpiringTokens = $AllTokens | Where-Object { $_.DaysUntilExpiration -le $ExpirationWarningDays -and $_.DaysUntilExpiration -gt 0 }\\n    if ($ExpiringTokens.Count -gt 0) {\\n        Write-Information \\\"üîÑ Renew $($ExpiringTokens.Count) token(s) expiring within $ExpirationWarningDays days:\\\" -InformationAction Continue\\n        foreach ($Token in $ExpiringTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType)) - expires in $($Token.DaysUntilExpiration) days\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    $FailedSyncTokens = $AllTokens | Where-Object { $_.LastSyncStatus -eq \\\"failed\\\" }\\n    if ($FailedSyncTokens.Count -gt 0) {\\n        Write-Information \\\"üîç Investigate $($FailedSyncTokens.Count) token(s) with failed sync status:\\\" -InformationAction Continue\\n        foreach ($Token in $FailedSyncTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType))\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    $ExpiredTokens = $AllTokens | Where-Object { $_.DaysUntilExpiration -le 0 }\\n    if ($ExpiredTokens.Count -gt 0) {\\n        Write-Information \\\"üö® Replace $($ExpiredTokens.Count) expired token(s) immediately:\\\" -InformationAction Continue\\n        foreach ($Token in $ExpiredTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType)) - expired $([math]::Abs($Token.DaysUntilExpiration)) days ago\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    if ($HealthyCount -eq $AllTokens.Count) {\\n        Write-Information \\\"‚úÖ All tokens are healthy! No action required.\\\" -InformationAction Continue\\n    }\\n    \\n    Write-Information \\\"`nReport saved to:\\\" -InformationAction Continue\\n    Write-Information \\\"üìÑ CSV: $CsvPath\\\" -InformationAction Continue\\n    \\n    Write-Information \\\"`n‚úì Apple token validity check completed successfully\\\" -InformationAction Continue\\n}\\ncatch {\\n    Write-Error \\\"Script failed: $($_.Exception.Message)\\\"\\n    exit 1\\n}\\nfinally {\\n    # Cleanup operations\\n    try {\\n        Disconnect-MgGraph -ErrorAction SilentlyContinue | Out-Null\\n        Write-Information \\\"Disconnected from Microsoft Graph\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Verbose \\\"Disconnect operation completed with warnings (this is expected behavior)\\\"\\n    }\\n}\\n\\n# ============================================================================\\n# SCRIPT SUMMARY\\n# ============================================================================\\n\\nWrite-Information \\\"\\n========================================\\nScript Execution Summary\\n========================================\\nScript: Apple Token & Certificate Validity Checker\\nTotal Items Checked: $($AllTokens.Count)\\n  ‚Ä¢ DEP Tokens: $(($AllTokens | Where-Object { $_.TokenType -eq 'DEP' }).Count)\\n  ‚Ä¢ APNS Certificates: $(($AllTokens | Where-Object { $_.TokenType -eq 'APNS' }).Count)\\nCritical Issues: $($CriticalIssues.Count)\\nStatus: Completed\\n========================================\\n\\\" -InformationAction Continue.Exception.Message)\\\"\\n        exit 1\\n    }\\n}# ============================================================================\\n# HELPER FUNCTIONS\\n# ============================================================================\\n\\n# Function to get all pages of results from Graph API\\nfunction Get-MgGraphPaginatedData {\\n    param(\\n        [Parameter(Mandatory = $true)]\\n        [string]$Uri,\\n        [int]$DelayMs = 100\\n    )\\n    \\n    $AllResult = @()\\n    $NextLink = $Uri\\n    $RequestCount = 0\\n    \\n    do {\\n        try {\\n            # Add delay to respect rate limits\\n            if ($RequestCount -gt 0) {\\n                Start-Sleep -Milliseconds $DelayMs\\n            }\\n            \\n            $Response = Invoke-MgGraphRequest -Uri $NextLink -Method GET\\n            $RequestCount++\\n            \\n            if ($Response.value) {\\n                $AllResult += $Response.value\\n            }\\n            else {\\n                $AllResult += $Response\\n            }\\n            \\n            $NextLink = $Response.'@odata.nextLink'\\n        }\\n        catch {\\n            if ($_.Exception.Message -like \\\"*429*\\\" -or $_.Exception.Message -like \\\"*throttled*\\\") {\\n                Write-Information \\\"`nRate limit hit, waiting 60 seconds...\\\" -InformationAction Continue\\n                Start-Sleep -Seconds 60\\n                continue\\n            }\\n            Write-Warning \\\"Error fetching data from $NextLink : $($_.Exception.Message)\\\"\\n            break\\n        }\\n    } while ($NextLink)\\n    \\n    return $AllResult\\n}\\n\\n# Function to determine token health status\\nfunction Get-TokenHealthStatus {\\n    param(\\n        [string]$State,\\n        [datetime]$ExpirationDate,\\n        [string]$LastSyncStatus,\\n        [int]$WarningDays\\n    )\\n    \\n    $DaysUntilExpiration = ($ExpirationDate - (Get-Date)).Days\\n    \\n    # Determine overall health\\n    if ($State -eq \\\"expired\\\" -or $DaysUntilExpiration -le 0) {\\n        return \\\"Critical\\\"\\n    }\\n    elseif ($State -eq \\\"invalid\\\" -or $LastSyncStatus -eq \\\"failed\\\") {\\n        return \\\"Critical\\\"\\n    }\\n    elseif ($DaysUntilExpiration -le $WarningDays) {\\n        return \\\"Warning\\\"\\n    }\\n    elseif ($State -eq \\\"valid\\\" -and $LastSyncStatus -eq \\\"completed\\\") {\\n        return \\\"Healthy\\\"\\n    }\\n    else {\\n        return \\\"Unknown\\\"\\n    }\\n}\\n\\n# Function to format time span\\nfunction Format-TimeSpan {\\n    param([datetime]$Date)\\n    \\n    $TimeSpan = $Date - (Get-Date)\\n    \\n    if ($TimeSpan.TotalDays -gt 0) {\\n        return \\\"$([math]::Round($TimeSpan.TotalDays)) days\\\"\\n    }\\n    elseif ($TimeSpan.TotalDays -gt -1) {\\n        return \\\"Today\\\"\\n    }\\n    else {\\n        return \\\"$([math]::Abs([math]::Round($TimeSpan.TotalDays))) days ago\\\"\\n    }\\n}\\n\\n# ============================================================================\\n# MAIN SCRIPT LOGIC\\n# ============================================================================\\n\\ntry {\\n    Write-Information \\\"Starting Apple token validity check...\\\" -InformationAction Continue\\n    \\n    # Initialize results arrays\\n    $AllTokens = @()\\n    $CriticalIssues = @()\\n    \\n    # ========================================================================\\n    # GET DEP TOKENS (ENROLLMENT PROGRAM TOKENS)\\n    # ========================================================================\\n    \\n    Write-Information \\\"Retrieving Apple DEP tokens...\\\" -InformationAction Continue\\n    \\n    try {\\n        $DepTokensUri = \\\"https://graph.microsoft.com/beta/deviceManagement/depOnboardingSettings\\\"\\n        $DepTokens = Get-MgGraphPaginatedData -Uri $DepTokensUri\\n        Write-Information \\\"Retrieving $($DepTokens.Count) DEP token entries...\\\" -InformationAction Continue\\n        \\n        $ValidDepTokenCount = 0\\n        foreach ($Token in $DepTokens) {\\n            try {\\n                # Skip if essential fields are missing\\n                if (-not $Token.tokenExpirationDateTime -or -not $Token.id) {\\n                    Write-Verbose \\\"Skipping DEP token entry with missing essential fields (ID: $($Token.id))\\\"\\n                    continue\\n                }\\n                \\n                $ExpirationDate = [datetime]$Token.tokenExpirationDateTime\\n                $LastSyncDate = if ($Token.lastSuccessfulSyncDateTime) { [datetime]$Token.lastSuccessfulSyncDateTime } else { $null }\\n                \\n                # DEP tokens don't have the same state enum as VPP, so we determine state based on expiration\\n                $State = if ($ExpirationDate -lt (Get-Date)) { \\\"expired\\\" } else { \\\"valid\\\" }\\n                $LastSyncStatus = if ($Token.lastSyncErrorCode -eq 0 -or $null -eq $Token.lastSyncErrorCode) { \\\"completed\\\" } else { \\\"failed\\\" }\\n                \\n                $HealthStatus = Get-TokenHealthStatus -State $State -ExpirationDate $ExpirationDate -LastSyncStatus $LastSyncStatus -WarningDays $ExpirationWarningDays\\n                \\n                $TokenInfo = [PSCustomObject]@{\\n                    TokenType            = \\\"DEP\\\"\\n                    TokenName            = if ($Token.tokenName) { $Token.tokenName } else { \\\"Unknown DEP Token\\\" }\\n                    AppleId              = if ($Token.appleIdentifier) { $Token.appleIdentifier } else { \\\"Unknown\\\" }\\n                    State                = $State\\n                    AccountType          = if ($Token.tokenType) { $Token.tokenType } else { \\\"Unknown\\\" }\\n                    CountryRegion        = \\\"N/A\\\"\\n                    ExpirationDateTime   = $ExpirationDate\\n                    DaysUntilExpiration  = ($ExpirationDate - (Get-Date)).Days\\n                    ExpirationStatus     = Format-TimeSpan -Date $ExpirationDate\\n                    LastSyncDateTime     = $LastSyncDate\\n                    LastSyncStatus       = $LastSyncStatus\\n                    AutoUpdateApps       = \\\"N/A\\\"\\n                    HealthStatus         = $HealthStatus\\n                    TokenId              = $Token.id\\n                    LastModifiedDateTime = if ($Token.lastModifiedDateTime) { [datetime]$Token.lastModifiedDateTime } else { $null }\\n                }\\n                \\n                $AllTokens += $TokenInfo\\n                $ValidDepTokenCount++\\n                \\n                # Track critical issues\\n                if ($HealthStatus -eq \\\"Critical\\\") {\\n                    $CriticalIssues += $TokenInfo\\n                }\\n            }\\n            catch {\\n                Write-Verbose \\\"Error processing DEP token (ID: $($Token.id)): $($_.Exception.Message)\\\"\\n                continue\\n            }\\n        }\\n        \\n        Write-Information \\\"‚úì Found $ValidDepTokenCount valid DEP tokens\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Warning \\\"Failed to retrieve DEP tokens: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # GET APPLE PUSH NOTIFICATION CERTIFICATE\\n    # ========================================================================\\n    \\n    Write-Information \\\"Retrieving Apple Push Notification Certificate...\\\" -InformationAction Continue\\n    \\n    try {\\n        $ApnsCertUri = \\\"https://graph.microsoft.com/v1.0/deviceManagement/applePushNotificationCertificate\\\"\\n        $ApnsCert = Invoke-MgGraphRequest -Uri $ApnsCertUri -Method GET\\n        \\n        if ($ApnsCert) {\\n            Write-Information \\\"‚úì Found Apple Push Notification Certificate\\\" -InformationAction Continue\\n            \\n            $ExpirationDate = [datetime]$ApnsCert.expirationDateTime\\n            $LastModifiedDate = if ($ApnsCert.lastModifiedDateTime) { [datetime]$ApnsCert.lastModifiedDateTime } else { $null }\\n            \\n            # Determine certificate state based on expiration and upload status\\n            $State = if ($ExpirationDate -lt (Get-Date)) { \\n                \\\"expired\\\" \\n            }\\n            elseif ([string]::IsNullOrEmpty($ApnsCert.certificateUploadFailureReason)) { \\n                \\\"valid\\\" \\n            }\\n            else { \\n                \\\"invalid\\\" \\n            }\\n            \\n            # Determine sync status based on certificate upload status and failure reason\\n            $LastSyncStatus = if ([string]::IsNullOrEmpty($ApnsCert.certificateUploadFailureReason)) { \\\"completed\\\" } else { \\\"failed\\\" }\\n            \\n            # Debug output to help understand the actual certificate status\\n            Write-Verbose \\\"APNS Certificate Debug Info:\\\"\\n            Write-Verbose \\\"  Upload Status: '$($ApnsCert.certificateUploadStatus)'\\\"\\n            Write-Verbose \\\"  Failure Reason: '$($ApnsCert.certificateUploadFailureReason)'\\\"\\n            Write-Verbose \\\"  Has Certificate: $([bool]$ApnsCert.certificate)\\\"\\n            Write-Verbose \\\"  Determined State: '$State'\\\"\\n            \\n            $HealthStatus = Get-TokenHealthStatus -State $State -ExpirationDate $ExpirationDate -LastSyncStatus $LastSyncStatus -WarningDays $ExpirationWarningDays\\n            \\n            $TokenInfo = [PSCustomObject]@{\\n                TokenType                      = \\\"APNS\\\"\\n                TokenName                      = \\\"Apple Push Notification Certificate\\\"\\n                AppleId                        = $ApnsCert.appleIdentifier\\n                State                          = $State\\n                AccountType                    = \\\"Push Certificate\\\"\\n                CountryRegion                  = \\\"N/A\\\"\\n                ExpirationDateTime             = $ExpirationDate\\n                DaysUntilExpiration            = ($ExpirationDate - (Get-Date)).Days\\n                ExpirationStatus               = Format-TimeSpan -Date $ExpirationDate\\n                LastSyncDateTime               = $LastModifiedDate\\n                LastSyncStatus                 = $LastSyncStatus\\n                AutoUpdateApps                 = \\\"N/A\\\"\\n                HealthStatus                   = $HealthStatus\\n                TokenId                        = $ApnsCert.id\\n                LastModifiedDateTime           = $LastModifiedDate\\n                TopicIdentifier                = $ApnsCert.topicIdentifier\\n                CertificateUploadStatus        = $ApnsCert.certificateUploadStatus\\n                CertificateUploadFailureReason = $ApnsCert.certificateUploadFailureReason\\n                CertificateSerialNumber        = $ApnsCert.certificateSerialNumber\\n            }\\n            \\n            $AllTokens += $TokenInfo\\n            \\n            # Track critical issues\\n            if ($HealthStatus -eq \\\"Critical\\\") {\\n                $CriticalIssues += $TokenInfo\\n            }\\n        }\\n        else {\\n            Write-Information \\\"‚ÑπÔ∏è No Apple Push Notification Certificate found\\\" -InformationAction Continue\\n        }\\n    }\\n    catch {\\n        Write-Warning \\\"Failed to retrieve Apple Push Notification Certificate: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # FILTER RESULTS IF REQUESTED\\n    # ========================================================================\\n    \\n    $ReportTokens = if ($OnlyShowProblems) {\\n        $AllTokens | Where-Object { $_.HealthStatus -in @(\\\"Critical\\\", \\\"Warning\\\") }\\n    }\\n    else {\\n        $AllTokens\\n    }\\n    \\n    # ========================================================================\\n    # GENERATE CSV REPORT\\n    # ========================================================================\\n    \\n    # Generate timestamp for file names\\n    $Timestamp = Get-Date -Format \\\"yyyy-MM-dd_HH-mm-ss\\\"\\n    $CsvPath = Join-Path $OutputPath \\\"Apple_Token_Validity_Report_$Timestamp.csv\\\"\\n    \\n    # Export to CSV\\n    try {\\n        $ReportTokens | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8\\n        Write-Information \\\"‚úì CSV report saved: $CsvPath\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Error \\\"Failed to generate CSV report: $($_.Exception.Message)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # SEND EMAIL ALERTS IF REQUESTED\\n    # ========================================================================\\n    \\n    if ($SendEmailAlert -and $CriticalIssues.Count -gt 0 -and $AlertEmailAddress) {\\n        Write-Information \\\"Sending email alert for critical issues...\\\" -InformationAction Continue\\n        # Note: Email functionality would require additional modules and configuration\\n        # This is a placeholder for future implementation\\n        Write-Warning \\\"Email alert functionality requires additional configuration (SMTP settings, etc.)\\\"\\n    }\\n    \\n    # ========================================================================\\n    # DISPLAY DETAILED CONSOLE OUTPUT\\n    # ========================================================================\\n    \\n    Write-Information \\\"`nüçé APPLE TOKEN & CERTIFICATE VALIDITY SUMMARY\\\" -InformationAction Continue\\n    Write-Information \\\"==============================================\\\" -InformationAction Continue\\n    Write-Information \\\"Total Items: $($AllTokens.Count)\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ DEP Tokens: $(($AllTokens | Where-Object { $_.TokenType -eq 'DEP' }).Count)\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ APNS Certificates: $(($AllTokens | Where-Object { $_.TokenType -eq 'APNS' }).Count)\\\" -InformationAction Continue\\n    Write-Information \\\"\\\" -InformationAction Continue\\n    \\n    # Health Status Summary\\n    $HealthyCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Healthy\\\" }).Count\\n    $WarningCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Warning\\\" }).Count\\n    $CriticalCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Critical\\\" }).Count\\n    $UnknownCount = ($AllTokens | Where-Object { $_.HealthStatus -eq \\\"Unknown\\\" }).Count\\n    \\n    Write-Information \\\"Health Status:\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Healthy: $HealthyCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Warning: $WarningCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Critical: $CriticalCount\\\" -InformationAction Continue\\n    Write-Information \\\"  ‚Ä¢ Unknown: $UnknownCount\\\" -InformationAction Continue\\n    \\n    # Display detailed token information\\n    if ($ReportTokens.Count -gt 0) {\\n        Write-Information \\\"`nüìã TOKEN DETAILS:\\\" -InformationAction Continue\\n        Write-Information \\\"=================\\\" -InformationAction Continue\\n        \\n        foreach ($Token in ($ReportTokens | Sort-Object HealthStatus, DaysUntilExpiration)) {\\n            $StatusIcon = switch ($Token.HealthStatus) {\\n                \\\"Healthy\\\" { \\\"‚úÖ\\\" }\\n                \\\"Warning\\\" { \\\"‚ö†Ô∏è\\\" }\\n                \\\"Critical\\\" { \\\"‚ùå\\\" }\\n                default { \\\"‚ùì\\\" }\\n            }\\n            \\n            $ItemType = if ($Token.TokenType -eq \\\"APNS\\\") { \\\"Certificate\\\" } else { \\\"Token\\\" }\\n            Write-Information \\\"`n$StatusIcon $($Token.TokenType) $ItemType : $($Token.TokenName)\\\" -InformationAction Continue\\n            Write-Information \\\"   Apple ID: $($Token.AppleId)\\\" -InformationAction Continue\\n            Write-Information \\\"   Status: $($Token.State)\\\" -InformationAction Continue\\n            Write-Information \\\"   Health: $($Token.HealthStatus)\\\" -InformationAction Continue\\n            Write-Information \\\"   Expires: $($Token.ExpirationDateTime.ToString('yyyy-MM-dd')) ($($Token.ExpirationStatus))\\\" -InformationAction Continue\\n            Write-Information \\\"   Last Modified: $(if ($Token.LastSyncDateTime) { $Token.LastSyncDateTime.ToString('yyyy-MM-dd HH:mm') } else { 'Never' })\\\" -InformationAction Continue\\n            Write-Information \\\"   Status: $($Token.LastSyncStatus)\\\" -InformationAction Continue\\n            \\n            if ($Token.TokenType -eq \\\"APNS\\\") {\\n                Write-Information \\\"   Topic Identifier: $($Token.TopicIdentifier)\\\" -InformationAction Continue\\n                Write-Information \\\"   Upload Status: $($Token.CertificateUploadStatus)\\\" -InformationAction Continue\\n                Write-Information \\\"   Serial Number: $($Token.CertificateSerialNumber)\\\" -InformationAction Continue\\n                if ($Token.CertificateUploadFailureReason) {\\n                    Write-Information \\\"   Upload Failure Reason: $($Token.CertificateUploadFailureReason)\\\" -InformationAction Continue\\n                }\\n            }\\n        }\\n    }\\n    \\n    # Critical Issues Alert\\n    if ($CriticalIssues.Count -gt 0) {\\n        Write-Information \\\"`n‚ö†Ô∏è  CRITICAL ISSUES DETECTED:\\\" -InformationAction Continue\\n        Write-Information \\\"=============================\\\" -InformationAction Continue\\n        foreach ($Issue in $CriticalIssues) {\\n            Write-Information \\\"‚ùå $($Issue.TokenName) ($($Issue.TokenType))\\\" -InformationAction Continue\\n            Write-Information \\\"   Issue: $($Issue.State)\\\" -InformationAction Continue\\n            Write-Information \\\"   Expires: $($Issue.ExpirationStatus)\\\" -InformationAction Continue\\n            Write-Information \\\"   Action Required: $(if ($Issue.State -eq 'expired') { 'Replace token immediately' } elseif ($Issue.State -eq 'invalid') { 'Check Apple Business Manager configuration' } else { 'Investigate sync issues' })\\\" -InformationAction Continue\\n            Write-Information \\\"\\\" -InformationAction Continue\\n        }\\n    }\\n    \\n    # Recommendations\\n    Write-Information \\\"`nüìã RECOMMENDATIONS:\\\" -InformationAction Continue\\n    Write-Information \\\"===================\\\" -InformationAction Continue\\n    \\n    $ExpiringTokens = $AllTokens | Where-Object { $_.DaysUntilExpiration -le $ExpirationWarningDays -and $_.DaysUntilExpiration -gt 0 }\\n    if ($ExpiringTokens.Count -gt 0) {\\n        Write-Information \\\"üîÑ Renew $($ExpiringTokens.Count) token(s) expiring within $ExpirationWarningDays days:\\\" -InformationAction Continue\\n        foreach ($Token in $ExpiringTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType)) - expires in $($Token.DaysUntilExpiration) days\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    $FailedSyncTokens = $AllTokens | Where-Object { $_.LastSyncStatus -eq \\\"failed\\\" }\\n    if ($FailedSyncTokens.Count -gt 0) {\\n        Write-Information \\\"üîç Investigate $($FailedSyncTokens.Count) token(s) with failed sync status:\\\" -InformationAction Continue\\n        foreach ($Token in $FailedSyncTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType))\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    $ExpiredTokens = $AllTokens | Where-Object { $_.DaysUntilExpiration -le 0 }\\n    if ($ExpiredTokens.Count -gt 0) {\\n        Write-Information \\\"üö® Replace $($ExpiredTokens.Count) expired token(s) immediately:\\\" -InformationAction Continue\\n        foreach ($Token in $ExpiredTokens) {\\n            Write-Information \\\"   ‚Ä¢ $($Token.TokenName) ($($Token.TokenType)) - expired $([math]::Abs($Token.DaysUntilExpiration)) days ago\\\" -InformationAction Continue\\n        }\\n        Write-Information \\\"\\\" -InformationAction Continue\\n    }\\n    \\n    if ($HealthyCount -eq $AllTokens.Count) {\\n        Write-Information \\\"‚úÖ All tokens are healthy! No action required.\\\" -InformationAction Continue\\n    }\\n    \\n    Write-Information \\\"`nReport saved to:\\\" -InformationAction Continue\\n    Write-Information \\\"üìÑ CSV: $CsvPath\\\" -InformationAction Continue\\n    \\n    Write-Information \\\"`n‚úì Apple token validity check completed successfully\\\" -InformationAction Continue\\n}\\ncatch {\\n    Write-Error \\\"Script failed: $($_.Exception.Message)\\\"\\n    exit 1\\n}\\nfinally {\\n    # Cleanup operations\\n    try {\\n        Disconnect-MgGraph -ErrorAction SilentlyContinue | Out-Null\\n        Write-Information \\\"Disconnected from Microsoft Graph\\\" -InformationAction Continue\\n    }\\n    catch {\\n        Write-Verbose \\\"Disconnect operation completed with warnings (this is expected behavior)\\\"\\n    }\\n}\\n\\n# ============================================================================\\n# SCRIPT SUMMARY\\n# ============================================================================\\n\\nWrite-Information \\\"\\n========================================\\nScript Execution Summary\\n========================================\\nScript: Apple Token & Certificate Validity Checker\\nTotal Items Checked: $($AllTokens.Count)\\n  ‚Ä¢ DEP Tokens: $(($AllTokens | Where-Object { $_.TokenType -eq 'DEP' }).Count)\\n  ‚Ä¢ APNS Certificates: $(($AllTokens | Where-Object { $_.TokenType -eq 'APNS' }).Count)\\nCritical Issues: $($CriticalIssues.Count)\\nStatus: Completed\\n========================================\\n\\\" -InformationAction Continue",
    "logVerbose": false
  },
  "outputs": {
    "deploymentInstructions": {
      "type": "string",
      "value": "Runbook created successfully! Next steps: 1) Publish the runbook draft, 2) Ensure your Automation Account has Managed Identity enabled, 3) Assign required Microsoft Graph permissions to the Managed Identity."
    },
    "runbookName": {
      "type": "string",
      "value": "[parameters('runbookName')]"
    },
    "automationAccountName": {
      "type": "string",
      "value": "[parameters('automationAccountName')]"
    },
    "runbookUrl": {
      "type": "string",
      "value": "[concat('https://portal.azure.com/#@', subscription().tenantId, '/resource/subscriptions/', subscription().subscriptionId, '/resourceGroups/', resourceGroup().name, '/providers/Microsoft.Automation/automationAccounts/', parameters('automationAccountName'), '/runbooks/', parameters('runbookName'))]"
    }
  },
  "resources": [
    {
      "apiVersion": "2020-01-13-preview",
      "type": "Microsoft.Automation/automationAccounts/runbooks",
      "properties": {
        "runbookType": "[variables('runbookType')]",
        "logProgress": "[variables('logProgress')]",
        "draft": {
          "inEdit": false
        },
        "description": "[parameters('runbookDescription')]",
        "logVerbose": "[variables('logVerbose')]"
      },
      "name": "[concat(parameters('automationAccountName'), '/', parameters('runbookName'))]"
    },
    {
      "apiVersion": "2020-01-13-preview",
      "type": "Microsoft.Automation/automationAccounts/runbooks/draft",
      "dependsOn": [
        "[resourceId('Microsoft.Automation/automationAccounts/runbooks', parameters('automationAccountName'), parameters('runbookName'))]"
      ],
      "properties": {
        "description": "[parameters('runbookDescription')]",
        "content": "[variables('scriptContent')]"
      },
      "name": "[concat(parameters('automationAccountName'), '/', parameters('runbookName'), '/draft')]"
    }
  ],
  "parameters": {
    "runbookDescription": {
      "defaultValue": "This script connects to Microsoft Graph and retrieves all Apple Device Enrollment Program (DEP) tokens",
      "type": "string",
      "metadata": {
        "description": "Description of the runbook"
      }
    },
    "runbookName": {
      "defaultValue": "check-apple-token-validity",
      "type": "string",
      "metadata": {
        "description": "Name for the new runbook (will be created in the Automation Account)"
      }
    },
    "automationAccountName": {
      "type": "string",
      "metadata": {
        "description": "Name of your existing Azure Automation Account (must exist in the selected resource group)"
      }
    }
  },
  "contentVersion": "1.0.0.0",
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#"
}
